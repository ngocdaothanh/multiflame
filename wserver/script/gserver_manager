#!/usr/bin/env ruby

abort "Usage: #{__FILE__} <development|production>" unless ARGV[0]

require 'rubygems'
require 'yaml'
require 'activerecord'
require 'revent/r_r'
require 'zlib'

RAILS_ROOT = "#{File.dirname(__FILE__)}/.."

if ARGV[0] == 'production'
  LOGGER = Logger.new("#{RAILS_ROOT}/log/gserver_manager.log", 'daily')
  LOGGER.level = Logger::INFO
else
  LOGGER = Logger.new(STDOUT)
end

database_yaml = YAML.load_file("#{RAILS_ROOT}/config/database.yml")
abort "Environment '#{ARGV[0]}' not found" unless database_config = database_yaml[ARGV[0]]
ActiveRecord::Base.establish_connection(database_config)
ActiveRecord::Base.logger = LOGGER

require "#{RAILS_ROOT}/config/initializers/config"
require "#{RAILS_ROOT}/app/models/game"
require "#{RAILS_ROOT}/app/models/game_container"
require "#{RAILS_ROOT}/app/models/stat"

# ------------------------------------------------------------------------------

# Game information is rarely changed. On startup, the manager will load
# information about all games into memory. When a gserver connects, it will be passed
# this information. When there is a change, the web server will notify the manager,
# and the manager in turn will push this change to all the gservers.
#
# Moreover, the manager may be down while the gservers are still alive. In this case,
# the gservers will try to connect to the manager every ~15sec. On startup, the
# manager will wait ~1min for all the gservers to connect and report their status
# (list of channels they are serving...).
class GserverManager
  include Revent::RRServer

  # Web -> manager
  CMD_WM_WHICH_FIFO       = 0
  CMD_WM_CG_RELOAD        = 1
  CMD_WM_SNAPSHOT_CREATE  = 2

  # Manager -> gserver
  CMD_MF_READY_SET        = 0
  CMD_MF_CG_SET           = 1
  CMD_MF_REMOTE_IPS_GET   = 2

  # Gserver -> manager
  CMD_FM_CHANNEL_KEYS_SET = 10
  CMD_FM_CHANNEL_CREATE   = 11
  CMD_FM_CHANNEL_DELETE   = 12

  def initialize(host, port)
    @mutex_channel_keys = Mutex.new
    @channel_keys = {}

    @ready = false

    @on_calls = {
      CMD_WM_WHICH_FIFO       => method(:on_call_wm_which_gserver),
      CMD_WM_CG_RELOAD        => method(:on_call_wm_cg_reload),
      CMD_WM_SNAPSHOT_CREATE  => method(:on_call_wm_snapshot_create),
      CMD_FM_CHANNEL_KEYS_SET => method(:on_call_fm_channel_keys_set),
      CMD_FM_CHANNEL_CREATE   => method(:on_call_fm_channel_create),
      CMD_FM_CHANNEL_DELETE   => method(:on_call_fm_channel_delete)
    }

    cg_reload
    EventMachine::add_timer(CONF[:gserver_manager_startup_delay]) do
      @ready = true
      clients.each { |gserver| mf_ready_set(gserver) }
    end

    EventMachine::add_periodic_timer(CONF[:gserver_manager_snapshot_interval]*60) do
      on_call_wm_snapshot_create(nil, nil)
    end

    start_server(host, port)
  end

  def on_connect(client)
    LOGGER.info("Client at #{client.remote_ip} connected")
    mf_cg_set(client)
    mf_ready_set(client) if @ready
  end

  def on_close(client)
    LOGGER.info("Client at #{client.remote_ip} disconnected")
    @mutex_channel_keys.synchronize do
      @channel_keys.delete(client)
    end
  end

  def on_call(client, cmd, value)
    m = @on_calls[cmd]
    m.call(client, value)
  end

  def on_result(client, cmd, value)
    if cmd == CMD_MF_REMOTE_IPS_GET
      on_result_mf_remote_ips_get(client, value)
    end
  end

  def on_error(client, cmd, value)
    backtrace = value.backtrace.join("\n")
    LOGGER.error("cmd = #{cmd}, error = #{backtrace}")
  end

private

  # Web server -> manager ------------------------------------------------------

  # Which gserver should handle a certain channel?
  # Input: {:game_id, :channel_name}
  # Output: {:game_id, :channel_name, :host, :port}
  def on_call_wm_which_gserver(gserver, value)
    @mutex_channel_keys.synchronize do
      return nil if @channel_keys.empty?

      # Take out the gserver the is handling this channel
      key = value
      gservers = @channel_keys.each do |f, keys|
        return [key, f.session[:swf_host], f.session[:swf_port]] if keys.include?(key)
      end

      # Take out the the emptiest gserver
      gservers = @channel_keys.keys
      max_gserver = gservers[0]
      max = gservers[0].session[:players_avalable]
      (1...gservers.size).each do |i|
        f = gservers[i]
        a = f.session[:players_avalable]
        if max < a
          max_gserver = f
          max = a
        end
      end
      return [key, max_gserver.session[:swf_host], max_gserver.session[:swf_port]]
    end
  end

  def on_call_wm_cg_reload(web, value)
    cg_reload
    clients.each { |f| mf_cg_set(f) }
    nil
  end

  # Load all information about the container and all games into a data
  # structure using only hash and arrays.
  def cg_reload
    container = GameContainer.instance
    games = Game.find(:all)
    @cg = {:c => {:version => container.updated_at.to_i}, :g => {}}
    games.each do |g|
      @cg[:g][g.id] = {:version => g.updated_at.to_i, :names => {}}
      CONF[:locales].each do |l|
        @cg[:g][g.id][:names][l] = g.name(l)
      end
    end
  end

  # Gservers -> manager -----------------------------------------------------------

  # The gservers call this right after connecting to the manager.
  def on_call_fm_channel_keys_set(gserver, value)
    @mutex_channel_keys.synchronize do
      gserver.session = value[:property]
      gserver.session[:players_available] = gserver.session[:players_limit]
      @channel_keys[gserver] = value[:channel_keys]
    end
    nil
  end

  # Ask the manager to create a channel. If the channel has already existed, let
  # the gserver know where to redirect the container to.
  # Returns nil if the calling gserver should handle the channel.
  def on_call_fm_channel_create(gserver, value)
    @mutex_channel_keys.synchronize do
      key = value
      host = port = nil
      @channel_keys.each do |f, keys|
        if keys.include?(key)
          host = f.session[:swf_host]
          port = f.session[:swf_port]
          break
        end
      end

      if host.nil?
        gserver.session[:players_available] -= 1
        @channel_keys[gserver] << key
      elsif gserver.session[:swf_host] == host and gserver.session[:swf_port] == port
        host = nil
        port = nil
      end
      return [key, host, port]
    end
  end

  # The channel has been deleted on the gserver.
  def on_call_fm_channel_delete(gserver, value)
    @mutex_channel_keys.synchronize do
      key = value
      @channel_keys[gserver].delete(key)
    end
    nil
  end

  # Manager -> gservers -----------------------------------------------------------

  def mf_ready_set(gserver)
    gserver.call(CMD_MF_READY_SET, nil)
  end

  def mf_cg_set(gserver)
    gserver.call(CMD_MF_CG_SET, @cg)
  end

  def channel_key(game_id, channel_name)
    "#{game_id}/#{channel_name}"
  end

  # ----------------------------------------------------------------------------

  # client is not nil if this method is strigged by the web.
  # Returns 0 if there's no gserver, nil if the snapshot will be written to DB.
  def on_call_wm_snapshot_create(client, value)
    if !client.nil?
      @num_gservers = clients.size - 1
    else
      @num_gservers = clients.size
    end
    return 0 if @num_gservers == 0

    @remote_ips_got = {}
    clients.each do |gserver|
      gserver.call(CMD_MF_REMOTE_IPS_GET, nil) if gserver != client
    end
    nil
  end

  def on_result_mf_remote_ips_get(gserver, value)
    value = Zlib::Inflate.inflate(value)
    value = Marshal.load(value)
    k = {:host => gserver.session[:swf_host], :port => gserver.session[:swf_port], :players_limit => gserver.session[:players_limit]}
    @remote_ips_got[k] = value
    return if @remote_ips_got.size < @num_gservers

    s = Stat.new
    s.snapshot = Zlib::Deflate.deflate(Marshal.dump(@remote_ips_got))
    s.save
  end
end

# ------------------------------------------------------------------------------

EventMachine::run do
  GserverManager.new(CONF[:gserver_manager_host], CONF[:gserver_manager_port])
  LOGGER.info("gserver manager started on #{CONF[:gserver_manager_host]}:#{CONF[:gserver_manager_port]}")
end
