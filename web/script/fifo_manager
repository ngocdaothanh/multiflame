#!/usr/bin/env ruby

abort "Usage: #{__FILE__} <environment>" unless ARGV[0]

require 'rubygems'
require 'revent'
require 'yaml'
require 'zlib'

require File.dirname(__FILE__) + '/../config/boot'
require 'actionmailer'
require File.dirname(__FILE__) + '/../config/initializers/config'
require 'activerecord'

require File.dirname(__FILE__) + '/../app/models/game'
require File.dirname(__FILE__) + '/../app/models/game_container'
require File.dirname(__FILE__) + '/../app/models/stat'

database_yaml = YAML.load_file("config/database.yml")
abort "Environment '#{ARGV[0]}' not found" unless database_config = database_yaml[ARGV[0]]
ActiveRecord::Base.establish_connection(database_config)

# ------------------------------------------------------------------------------

# Game information is rarely changed. On startup, the manager will load
# information about all games into memory. When a fifo connects, it will be passed
# this information. When there is a change, the web server will notify the manager,
# and the manager in turn will push this change to all the fifos.
#
# Moreover, the manager may be down while the fifos are still alive. In this case,
# the fifos will try to connect to the manager every ~15sec. On startup, the
# manager will wait ~1min for all the fifos to connect and report their status
# (list of channels they are serving...).
class FifoManager
  include ReventServer

  # Web -> manager
  CMD_WM_WHICH_FIFO       = 0
  CMD_WM_CG_RELOAD        = 1

  # Manager -> fifo
  CMD_MF_READY            = 0
  CMD_MF_CG_SET           = 1
  CMD_MF_CAPTCHA_SALT_SET = 2

  # Fifo -> manager
  CMD_FM_CHANNEL_KEYS_SET = 10
  CMD_FM_CHANNEL_CREATE   = 11

  def initialize
    @mutex_channel_keys = Mutex.new
    @channel_keys = {}
    @ready = false

    @on_calls = {
      CMD_WM_WHICH_FIFO       => method(:on_call_wm_which_fifo),
      CMD_WM_CG_RELOAD        => method(:on_call_wm_cg_reload),
      CMD_FM_CHANNEL_KEYS_SET => method(:on_call_fm_channel_keys_set),
      CMD_FM_CHANNEL_CREATE   => method(:on_call_fm_channel_create)
    }

    cg_reload
    EventMachine::add_timer(CONFIG[:fifo_manager_startup_delay]) do
      @ready = true
      clients.each { |fifo| mf_ready(fifo) }
    end

    EventMachine::add_periodic_timer(CONFIG[:fifo_manager_snapshot_interval]*60) do
      create_snapshot
    end

    start_server(CONFIG[:fifo_manager_host], CONFIG[:fifo_manager_port])
  end

  def on_connect(client)
    mf_cg_set(client)
    mf_ready(client) if @ready
  end

  def on_close(client)
    @mutex_channel_keys.synchronize do
      @channel_keys.delete(client)
    end
  end

  def on_call(client, cmd, arg)
    m = @on_calls[cmd]
    m.call(client, arg)
  end

  def on_result(client, cmd, error)
  end

  def on_error(client, cmd, error)
  end

private

  # Web server -> manager ------------------------------------------------------

  # Which fifo should handle a certain channel?
  # Input: {:game_id, :channel_name}
  # Output: {:game_id, :channel_name, :host, :port}
  def on_call_wm_which_fifo(fifo, arg)
    @mutex_channel_keys.synchronize do
      return nil if @channel_keys.empty?

      # Take out the fifo the is handling this channel
      key = arg
      fifos = @channel_keys.each do |f, keys|
        return [key, f.remote_ip, f.property[:port]] if keys.include?(key)
      end

      # Take out the the emptiest fifo
      fifos = @channel_keys.keys
      max_fifo = fifos[0]
      max = fifos[0].property[:players_avalable]
      (1...fifos.size).each do |i|
        f = fifos[i]
        a = f.property[:players_avalable]
        if max < a
          max_fifo = f
          max = a
        end
      end
      return [key, max_fifo.remote_ip, max_fifo.property[:port]]
    end
  end

  def on_call_wm_cg_reload(client, arg)
    cg_reload

    clients.each { |fifo| mf_cg_set(fifo) }
    nil
  end

  # Load all information about the container and all games into a data
  # structure using only hash and arrays.
  def cg_reload
    container = GameContainer.instance
    games = Game.find(:all)
    @cg = {:c => {:version => container.updated_at.to_i}, :g => {}}
    games.each do |g|
      @cg[:g][g.id] = {:version => g.updated_at.to_i, :names => {}}
      LOCALES.each do |l|
        @cg[:g][g.id][:names][l] = g.name(l)
      end
    end
  end

  # Fifos -> manager -----------------------------------------------------------

  # The fifos call this right after connecting to the manager.
  def on_call_fm_channel_keys_set(fifo, arg)
    @mutex_channel_keys.synchronize do
      fifo.property = arg[:property]
      fifo.property[:players_available] = fifo.property[:players_limit]
      @channel_keys[fifo] = arg[:channel_keys]
    end
    nil
  end

  # Ask the manager to create a channel. If the channel has already existed, let
  # the fifo know where to redirect the container to.
  # Returns nil if this 
  def on_call_fm_channel_create(fifo, arg)
    @mutex_channel_keys.synchronize do
      key = arg
      host = port = nil
      @channel_keys.each do |f, keys|
        if keys.include?(key)
          host = f.remote_ip
          port = f.property[:port]
          break
        end
      end

      if host.nil?
        fifo.property[:players_available] -= 1
        @channel_keys[fifo] << key
      end
      return [key, host, port]
    end
  end

  # The channel has been deleted on the fifo.
  def on_call_fm_channel_delete(fifo, arg)
    @mutex_channel_keys.synchronize do
      key = arg
      @channel_keys[fifo].delete(key)
    end
    nil
  end

  # Manager -> fifos -----------------------------------------------------------

  def mf_ready(fifo)
    fifo.call(CMD_MF_READY, nil)
  end

  def mf_cg_set(fifo)
    fifo.call(CMD_MF_CG_SET, @cg)
  end

  def mf_captcha_salt_set(fifo)
    fifo.call(CMD_MF_CAPTCHA_SALT_SET, @captcha_salt)
  end

  def channel_key(game_id, channel_name)
    "#{game_id}/#{channel_name}"
  end

  # ----------------------------------------------------------------------------

  def prepare_snapshot
    ret = {}
    @channel_keys.each do |fifo, keys|
      k = {:host => fifo.remote_ip, :port => fifo.property[:port]}
      ret[k] = {:players_limit => fifo.property[:players_limit], :keys => keys}
    end
    ret
  end

  def create_snapshot
    s = Stat.new
    s.snapshot = Zlib::Deflate.deflate(Marshal.dump(prepare_snapshot))
    s.save
  end
end

# ------------------------------------------------------------------------------

$LOGGER = Logger.new(STDOUT, 'daily')

EventMachine::run do
  FifoManager.new
  $LOGGER.info("Fifo manager started on #{CONFIG[:fifo_manager_host]}:#{CONFIG[:fifo_manager_port]}")
end