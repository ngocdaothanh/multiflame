#!/usr/bin/env ruby

abort "Usage: #{__FILE__} <environment>" unless ARGV[0]

require 'rubygems'
require 'revent'
require 'yaml'
require File.dirname(__FILE__) + '/../config/boot'
require 'actionmailer'
require File.dirname(__FILE__) + '/../config/initializers/config'
require 'activerecord'

require File.dirname(__FILE__) + '/../app/models/game'
require File.dirname(__FILE__) + '/../app/models/game_container'

database_yaml = YAML.load_file("config/database.yml")
abort "Environment '#{ARGV[0]}' not found" unless database_config = database_yaml[ARGV[0]]
ActiveRecord::Base.establish_connection(database_config)

# ------------------------------------------------------------------------------

# Game information is rarely changed. On startup, the manager will load
# information about all games into memory. When a fifo connects, it will be passed
# this information. When there is a change, the web server will notify the manager,
# and the manager in turn will push this change to all the fifos.
#
# Moreover, the manager may be down while the fifos are still alive. In this case,
# the fifos will try to connect to the manager every ~15sec. On startup, the
# manager will wait ~1min for all the fifos to connect and report their status
# (list of channels they are serving...).
class FifoManager
  include ReventServer

  # Web -> manager
  CMD_WM_CHANNEL_KEYS_GET = 0
  CMD_WM_CG_RELOAD        = 1

  # Manager -> fifo
  CMD_MF_READY            = 0
  CMD_MF_CG_SET           = 1
  CMD_MF_CAPTCHA_SALT_SET = 2

  # Fifo -> manager
  CMD_FM_CHANNEL_KEYS_SET = 10
  CMD_FM_CHANNEL_CREATE   = 11

  def initialize
    @mutex_channel_keys = Mutex.new
    @channel_keys = {}
    @ready = false

    @on_calls = {
      CMD_WM_CHANNEL_KEYS_GET => method(:on_call_wm_channel_keys_get),
      CMD_WM_CG_RELOAD        => method(:on_call_wm_cg_reload),
      CMD_FM_CHANNEL_KEYS_SET => method(:on_call_fm_channel_keys_set),
      CMD_FM_CHANNEL_CREATE   => method(:on_call_fm_channel_create)
    }

    cg_reload
    EventMachine::add_timer(CONFIG[:startup_wait_time]) do
      @ready = true
      clients.each { |fifo| mf_ready(fifo) }
    end
    start_server(CONFIG[:fifo_manager_host], CONFIG[:fifo_manager_port])
  end

  def on_connect(client)
    mf_cg_set(client)
    mf_ready(client) if @ready
  end

  def on_close(client)
    @mutex_channel_keys.synchronize do
      @channel_keys.delete(client)
    end
  end

  def on_call(client, cmd, arg)
    m = @on_calls[cmd]
    m.call(client, arg)
  end

  def on_result(client, cmd, error)
  end

  def on_error(client, cmd, error)
  end

private

  # Web server -> manager ------------------------------------------------------

  def on_call_wm_channel_keys_get(client, arg)
    ret = {}
    @channel_keys.each do |fifo, keys|
      k = {:host => fifo.remote_ip, :port => fifo.property[:port]}
      ret[k] = {:players_limit => fifo.property[:players_limit], :keys => keys}
    end
    ret
  end

  def on_call_wm_cg_reload
    cg_reload

    clients.each { |fifo| mf_cg_set(fifo) }
    nil
  end

  # Load all information about the container and all games into a data
  # structure using only hash and arrays.
  def cg_reload
    container = GameContainer.instance
    games = Game.find(:all)
    @cg = {:c => {:version => container.updated_at.to_i}, :g => {}}
    games.each do |g|
      @cg[:g][g.id] = {:version => g.updated_at.to_i, :names => {}}
      LOCALES.each do |l|
        @cg[:g][g.id][:names][l] = g.name(l)
      end
    end
  end

  # Fifos -> manager -----------------------------------------------------------

  # The fifos call this right after connecting to the manager.
  def on_call_fm_channel_keys_set(fifo, arg)
    @mutex_channel_keys.synchronize do
      fifo.property = arg[:property]
      @channel_keys[fifo] = arg[:channel_keys]
    end
    nil
  end

  # Ask the manager to create a channel. If the channel has already existed, let
  # the fifo know where to redirect the container to.
  # Returns nil if this 
  def on_call_fm_channel_create(fifo, arg)
    @mutex_channel_keys.synchronize do
      key = arg
      host = port = nil
      @channel_keys.each do |f, keys|
        if keys.include?(key)
          host = f.remote_ip
          port = f.property[:port]
          break
        end
      end

      if host.nil?
        destination =  nil
        @channel_keys[fifo] << key
      else
        destination =  {:host => host, :port => port}
      end
      return {:key => key, :destination => destination}
    end
  end

  # The channel has been deleted on the fifo.
  def on_call_fm_channel_delete(fifo, arg)
    @mutex_channel_keys.synchronize do
      key = arg
      @channel_keys[fifo].delete(key)
    end
    nil
  end

  # Manager -> fifos -----------------------------------------------------------

  def mf_ready(fifo)
    fifo.call(CMD_MF_READY, nil)
  end

  def mf_cg_set(fifo)
    fifo.call(CMD_MF_CG_SET, @cg)
  end

  def mf_captcha_salt_set(fifo)
    fifo.call(CMD_MF_CAPTCHA_SALT_SET, @captcha_salt)
  end

  def channel_key(game_id, channel_name)
    "#{game_id}/#{channel_name}"
  end
end

# ------------------------------------------------------------------------------

$LOGGER = Logger.new(STDOUT, 'daily')

EventMachine::run do
  FifoManager.new
  $LOGGER.info("Fifo manager started on #{CONFIG[:fifo_manager_host]}:#{CONFIG[:fifo_manager_port]}")
end