#!/usr/bin/env ruby

abort "Usage: #{__FILE__} <environment>" unless ARGV[0]

require 'rubygems'
require 'activerecord'
require 'yaml'
require 'revent/r_r'
require 'zlib'

RAILS_ROOT = "#{File.dirname(__FILE__)}/.."
require "#{RAILS_ROOT}/config/initializers/config"
require "#{RAILS_ROOT}/app/models/game"
require "#{RAILS_ROOT}/app/models/game_container"
require "#{RAILS_ROOT}/app/models/stat"

database_yaml = YAML.load_file("#{RAILS_ROOT}/config/database.yml")
abort "Environment '#{ARGV[0]}' not found" unless database_config = database_yaml[ARGV[0]]

$LOGGER = Logger.new(STDOUT, 'daily')

ActiveRecord::Base.establish_connection(database_config)
ActiveRecord::Base.logger = $LOGGER

# ------------------------------------------------------------------------------

# Game information is rarely changed. On startup, the manager will load
# information about all games into memory. When a fifo connects, it will be passed
# this information. When there is a change, the web server will notify the manager,
# and the manager in turn will push this change to all the fifos.
#
# Moreover, the manager may be down while the fifos are still alive. In this case,
# the fifos will try to connect to the manager every ~15sec. On startup, the
# manager will wait ~1min for all the fifos to connect and report their status
# (list of channels they are serving...).
class FifoManager
  include Revent::RRServer

  # Web -> manager
  CMD_WM_WHICH_FIFO       = 0
  CMD_WM_CG_RELOAD        = 1
  CMD_WM_SNAPSHOT_CREATE  = 2

  # Manager -> fifo
  CMD_MF_READY_SET        = 0
  CMD_MF_CG_SET           = 1
  CMD_MF_REMOTE_IPS_GET   = 2
  CMD_MF_CAPTCHA_SALT_SET = 3

  # Fifo -> manager
  CMD_FM_CHANNEL_KEYS_SET = 10
  CMD_FM_CHANNEL_CREATE   = 11
  CMD_FM_CHANNEL_DELETE   = 12

  SALT_LENGTH = 6

  def initialize(host, port)
    @mutex_channel_keys = Mutex.new
    @channel_keys = {}

    new_captcha_salt
    @ready = false

    @on_calls = {
      CMD_WM_WHICH_FIFO       => method(:on_call_wm_which_fifo),
      CMD_WM_CG_RELOAD        => method(:on_call_wm_cg_reload),
      CMD_WM_SNAPSHOT_CREATE  => method(:on_call_wm_snapshot_create),
      CMD_FM_CHANNEL_KEYS_SET => method(:on_call_fm_channel_keys_set),
      CMD_FM_CHANNEL_CREATE   => method(:on_call_fm_channel_create),
      CMD_FM_CHANNEL_DELETE   => method(:on_call_fm_channel_delete)
    }

    cg_reload
    EventMachine::add_timer(CONFIG[:fifo_manager_startup_delay]) do
      @ready = true
      clients.each { |fifo| mf_ready_set(fifo) }
    end

    EventMachine::add_timer(CONFIG[:captcha_salt_renew_interval]*60) do
      mf_captcha_salt_set
    end

    EventMachine::add_periodic_timer(CONFIG[:fifo_manager_snapshot_interval]*60) do
      on_call_wm_snapshot_create(nil, nil)
    end

    start_server(host, port)
  end

  def on_connect(client)
    mf_cg_set(client)
    client.call(CMD_MF_CAPTCHA_SALT_SET, @captcha_salt)
    mf_ready_set(client) if @ready
  end

  def on_close(client)
    @mutex_channel_keys.synchronize do
      @channel_keys.delete(client)
    end
  end

  def on_call(client, cmd, value)
    m = @on_calls[cmd]
    m.call(client, value)
  end

  def on_result(client, cmd, value)
    if cmd == CMD_MF_REMOTE_IPS_GET
      on_result_mf_remote_ips_get(client, value)
    end
  end

  def on_error(client, cmd, value)
    backtrace = value.backtrace.join("\n")
    $LOGGER.error("cmd = #{cmd}, error = #{backtrace}")
  end

private

  # Web server -> manager ------------------------------------------------------

  # Which fifo should handle a certain channel?
  # Input: {:game_id, :channel_name}
  # Output: {:game_id, :channel_name, :host, :port}
  def on_call_wm_which_fifo(fifo, value)
    @mutex_channel_keys.synchronize do
      return nil if @channel_keys.empty?

      # Take out the fifo the is handling this channel
      key = value
      fifos = @channel_keys.each do |f, keys|
        return [key, f.property[:swf_host], f.property[:swf_port]] if keys.include?(key)
      end

      # Take out the the emptiest fifo
      fifos = @channel_keys.keys
      max_fifo = fifos[0]
      max = fifos[0].property[:players_avalable]
      (1...fifos.size).each do |i|
        f = fifos[i]
        a = f.property[:players_avalable]
        if max < a
          max_fifo = f
          max = a
        end
      end
      return [key, max_fifo.property[:swf_host], max_fifo.property[:swf_port]]
    end
  end

  def on_call_wm_cg_reload(web, value)
    cg_reload
    clients.each { |f| mf_cg_set(f) }
    nil
  end

  # Load all information about the container and all games into a data
  # structure using only hash and arrays.
  def cg_reload
    container = GameContainer.instance
    games = Game.find(:all)
    @cg = {:c => {:version => container.updated_at.to_i}, :g => {}}
    games.each do |g|
      @cg[:g][g.id] = {:version => g.updated_at.to_i, :names => {}}
      CONFIG[:locales].each do |l|
        @cg[:g][g.id][:names][l] = g.name(l)
      end
    end
  end

  # Fifos -> manager -----------------------------------------------------------

  # The fifos call this right after connecting to the manager.
  def on_call_fm_channel_keys_set(fifo, value)
    @mutex_channel_keys.synchronize do
      fifo.property = value[:property]
      fifo.property[:players_available] = fifo.property[:players_limit]
      @channel_keys[fifo] = value[:channel_keys]
    end
    nil
  end

  # Ask the manager to create a channel. If the channel has already existed, let
  # the fifo know where to redirect the container to.
  # Returns nil if the calling fifo should handle the channel.
  def on_call_fm_channel_create(fifo, value)
    @mutex_channel_keys.synchronize do
      key = value
      host = port = nil
      @channel_keys.each do |f, keys|
        if keys.include?(key)
          host = f.property[:swf_host]
          port = f.property[:swf_port]
          break
        end
      end

      if host.nil?
        fifo.property[:players_available] -= 1
        @channel_keys[fifo] << key
      elsif fifo.property[:swf_host] == host and fifo.property[:swf_port] == port
        host = nil
        port = nil
      end
      return [key, host, port]
    end
  end

  # The channel has been deleted on the fifo.
  def on_call_fm_channel_delete(fifo, value)
    @mutex_channel_keys.synchronize do
      key = value
      @channel_keys[fifo].delete(key)
    end
    nil
  end

  # Manager -> fifos -----------------------------------------------------------

  def mf_ready_set(fifo)
    fifo.call(CMD_MF_READY_SET, nil)
  end

  def mf_cg_set(fifo)
    fifo.call(CMD_MF_CG_SET, @cg)
  end

  def mf_captcha_salt_set
    new_captcha_salt
    clients.each { |fifo| fifo.call(CMD_MF_CAPTCHA_SALT_SET, @captcha_salt) }
  end

  def new_captcha_salt
    chars = ('A'..'Z').to_a
    salt_array = []
    1.upto(SALT_LENGTH) { salt_array << chars[rand(chars.length)] }
    @captcha_salt = salt_array.join('')
  end

  def channel_key(game_id, channel_name)
    "#{game_id}/#{channel_name}"
  end

  # ----------------------------------------------------------------------------

  # client is not nil if this method is strigged by the web.
  # Returns 0 if there's no fifo, nil if the snapshot will be written to DB.
  def on_call_wm_snapshot_create(client, value)
    if !client.nil?
      @num_fifos = clients.size - 1
    else
      @num_fifos = clients.size 
    end
    return 0 if @num_fifos == 0

    @remote_ips_got = {}
    clients.each do |fifo|
      fifo.call(CMD_MF_REMOTE_IPS_GET, nil) if fifo != client
    end
    nil
  end

  def on_result_mf_remote_ips_get(fifo, value)
    value = Zlib::Inflate.inflate(value)
    value = Marshal.load(value)
    k = {:host => fifo.property[:swf_host], :port => fifo.property[:swf_port], :players_limit => fifo.property[:players_limit]}
    @remote_ips_got[k] = value
    return if @remote_ips_got.size < @num_fifos

    s = Stat.new
    s.snapshot = Zlib::Deflate.deflate(Marshal.dump(@remote_ips_got))
    s.save
  end
end

# ------------------------------------------------------------------------------

EventMachine::run do
  FifoManager.new(CONFIG[:fifo_manager_host], CONFIG[:fifo_manager_port])
  $LOGGER.info("Fifo manager started on #{CONFIG[:fifo_manager_host]}:#{CONFIG[:fifo_manager_port]}")
end